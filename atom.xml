<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ihww's Blog]]></title>
  <subtitle><![CDATA[懒懒散散，恍恍惚惚，提笔忘字]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.ihww.cn/"/>
  <updated>2014-12-17T03:22:15.164Z</updated>
  <id>http://blog.ihww.cn/</id>
  
  <author>
    <name><![CDATA[ihuangweiwei]]></name>
    <email><![CDATA[ihuangweiwei@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Markdown标签速查]]></title>
    <link href="http://blog.ihww.cn/2014/12/16/markdown/Markdown%E6%A0%87%E7%AD%BE%E9%80%9F%E6%9F%A5/"/>
    <id>http://blog.ihww.cn/2014/12/16/markdown/Markdown标签速查/</id>
    <published>2014-12-16T06:12:39.000Z</published>
    <updated>2014-12-16T06:31:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Markdown速记手册">Markdown速记手册</h2>
<p>截了ghost博客提供的一张Markdown速记图片</p>
<p><img src="/images/201412/Markdown_1.png" alt="Markdown速记手册"></p>
<p>Markdown语法参考：<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">http://wowubuntu.com/markdown/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Markdown速记手册">Markdown速记手册</h2>
<p>截了ghost博客提供的一张Markdown速记图片</p>
<p><img src="/images/201412/Markdown_1.png" alt="Markdown速记手册"></p]]>
    </summary>
    
      <category term="Markdown" scheme="http://blog.ihww.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript高级程序设计-读书笔记（上）]]></title>
    <link href="http://blog.ihww.cn/2014/12/12/javascript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://blog.ihww.cn/2014/12/12/javascript/JavaScript高级程序设计-读书笔记（上）/</id>
    <published>2014-12-12T08:30:13.000Z</published>
    <updated>2014-12-16T11:35:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1_JavaScript简介">1 JavaScript简介</h2>
<h3 id="1-2_JavaScript实现">1.2  JavaScript实现</h3>
<ul>
<li>核心（ECMAScript）</li>
<li>文档对象模型（DOM）</li>
<li>浏览器对象模型（BOM）</li>
</ul>
<h4 id="1-2-1_ECMAScript（提供核心语言功能）">1.2.1   ECMAScript（提供核心语言功能）</h4>
<p>规定了该门语言的下列组成部分：语法、类型、语句、关键字、保留字、操作符、对象</p>
<h4 id="1-2-2_文档对象模型（DOM）（提供访问和操作网页内容的方法和接口）">1.2.2   文档对象模型（DOM）（提供访问和操作网页内容的方法和接口）</h4>
<p>是针对XML但经过扩展用于HTML的应用程序编程接口。</p>
<p>2.DOM级别</p>
<p>DOM1级有两个模块组成：DOM核心 和 DOM HTML.（思考两个模块干嘛的）<br>DOM2级的模块：DOM试图，DOM事件（事件和事件处理的接口），DOM样式（基于CSS为元素应用样式的接口），DOM遍历和范围（遍历和操作文档树的接口）</p>
<p>3.其他DOM标准</p>
<p>SVG、MathML、SMIL</p>
<a id="more"></a>

<h4 id="1-2-3_浏览器对象模型（BOM）（提供与浏览器交互的方法和接口）">1.2.3   浏览器对象模型（BOM）（提供与浏览器交互的方法和接口）</h4>
<p>一些扩展：</p>
<ul>
<li>navigator（浏览器信息）</li>
<li>location（页面详细信息）</li>
<li>screen（显示器分辨率详细信息）</li>
<li>对cookies的支持</li>
<li>如XMLHttpRequest、ActiveXObject 自定义对象</li>
</ul>
<h2 id="2_在HTML中使用JavaScript">2 在HTML中使用JavaScript</h2>
<h4 id="2-1-2_延迟脚本">2.1.2   延迟脚本</h4>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">defer</span>=<span class="value">"defer"</span> <span class="attribute">src</span>=<span class="value">"example1.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>告诉浏览器立即下载，但延迟执行（有浏览器忽略该属性）</p>
<h4 id="2-1-3_异步脚本">2.1.3   异步脚本</h4>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">async</span> <span class="attribute">src</span>=<span class="value">"example1.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><h3 id="2-4_元素">2.4  <noscript>元素</noscript></h3>
<p>符合以下情况，元素内内容会显示</p>
<ul>
<li>浏览器不支持脚本</li>
<li>脚本被禁用</li>
</ul>
<h2 id="3_基本概念">3 基本概念</h2>
<h3 id="3-1_语法">3.1  语法</h3>
<h4 id="3-1-1_区分大小写">3.1.1   区分大小写</h4>
<h4 id="3-1-2_标示符">3.1.2   标示符</h4>
<p>标示符指的是变量、函数、属性的名字，函数的参数。</p>
<ul>
<li>第一个字符必须是字母、_或$</li>
<li>其它字符可以是字母、下划线、美元符号或数字</li>
</ul>
<h4 id="3-1-4_严格模式">3.1.4   严格模式</h4>
<pre><code><span class="pi">"use strict"</span>
</code></pre><p>是一个编译指示（pragma），告诉支持的JavaScript引擎切换到严格模式。<code>函数内部也可以使用</code></p>
<h3 id="3-4_数据类型">3.4  数据类型</h3>
<p>ECMAScript中有5种简单数据类型：Undefined、Null、Boolean、Number和String。一种复杂数据类型：Object（本质上是由一组无序的明值对组成）。</p>
<h4 id="3-4-1_typeof操作符">3.4.1   typeof操作符</h4>
<p>返回某个字符串</p>
<h4 id="3-4-2_Undefined类型">3.4.2   Undefined类型</h4>
<p>Undefined类型只有<strong>一个值</strong>，即特殊的<strong>undefined</strong></p>
<pre><code><span class="literal">undefined</span>==<span class="literal">undefined</span>    返回<span class="literal">true</span>
</code></pre><h4 id="3-4-3_Null类型">3.4.3   Null类型</h4>
<p>Null类型是第二个只有一个值的数据类型，是null。null值表示一个空对象指针，所以typeof检测null值会返回”object”的原因。</p>
<p>undefined值是派生自null值的</p>
<pre><code><span class="literal">null</span>==<span class="literal">undefined</span> 返回<span class="literal">true</span>
</code></pre><h4 id="3-4-4_Boolean类型">3.4.4    Boolean类型</h4>
<p>各种数据类型及其对应的转换规则</p>
<h4 id="3-4-5_Number类型">3.4.5   Number类型</h4>
<ol>
<li>数值范围<br>Number.MAX_VALUE<br>Number.MIN_VALUE</li>
</ol>
<p>超出数值范围的值，会自动换换成特殊的Infinity值（负数转换为-Infinity(负无穷)）</p>
<ol>
<li>NaN<br>NaN，即非数值，是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。</li>
</ol>
<p>两个特点：</p>
<ul>
<li>任何涉及NaN的操作都返回NaN</li>
<li>NaN与任何值都不相等，包括NaN本身</li>
</ul>
<ol>
<li>数值转换<br>略</li>
</ol>
<h4 id="3-4-6_String类型">3.4.6   String类型</h4>
<p>用于表示由0或多个16位Unicode字符组成的字符串序列，即字符串。</p>
<ol>
<li>字符串的特点</li>
</ol>
<p>ECMAScript中的字符串是不可变的。</p>
<h4 id="3-4-7_Object类型">3.4.7   Object类型</h4>
<p>ECMAScript中的对象其实就是一组数据和功能的集合。</p>
<h3 id="3-5_操作符">3.5  操作符</h3>
<h4 id="3-5-7_相等操作符">3.5.7   相等操作符</h4>
<p><strong>相等(==)和不相等（!=）</strong>：想转换再比较</p>
<p><strong>全等(===)和不全等(!==)</strong>：仅比较而不转换</p>
<h3 id="3-6_语句">3.6  语句</h3>
<p>if  do-while    while   for for-in  label   break和continue  with    switch</p>
<h3 id="3-7_函数">3.7  函数</h3>
<h4 id="3-7-1_理解参数">3.7.1   理解参数</h4>
<p>ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么类型。在函数体内可以通过<code>arguments</code>对象来访问这个参数数组。</p>
<h4 id="3-7-2_没有重载">3.7.2   没有重载</h4>
<p>ECMAScript函数没有签名，因为其参数是由包含0或多个值的数组来表示的。</p>
<h2 id="4_变量、作用域和内存问题">4 变量、作用域和内存问题</h2>
<h3 id="4-1_基本类型和引用类型的值">4.1  基本类型和引用类型的值</h3>
<p>JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。</p>
<h4 id="4-1-1_动态的属性">4.1.1   动态的属性</h4>
<p>引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。（基本类型不行）</p>
<h4 id="4-1-2_复制变量值">4.1.2   复制变量值</h4>
<p>基本类型：如果一个变量想另一个变量复制基本类型的值，会在变量对象上创建一个新值。<br>引用类型：复制结束后，两个变量实际上将引用同一个对象。</p>
<h4 id="4-1-3_传递参数">4.1.3   传递参数</h4>
<p>ECMAScript中所有函数的参数都是按值传递的。（把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样）。</p>
<h4 id="4-1-4_检测类型">4.1.4   检测类型</h4>
<p><code>typeof</code>在检测引用类型的值时，这个操作符的用处不大。所以有了<code>instanceof</code>，所有引用类型的值都是Object的实例。</p>
<h3 id="4-2_执行环境及作用域">4.2  执行环境及作用域</h3>
<p>每个执行环境都是一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。（编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它）</p>
<p>全局执行环境是最外围的一个执行环境。</p>
<p>每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。（保证对执行环境有权访问的所有变量和函数的有序访问）</p>
<p><strong>需要补充</strong></p>
<p>//TODO</p>
<h3 id="4-3_垃圾收集">4.3  垃圾收集</h3>
<h4 id="4-3-1_标记清除">4.3.1   标记清除</h4>
<h4 id="4-3-2_引用计数">4.3.2   引用计数</h4>
<h2 id="5_引用类型">5 引用类型</h2>
<p>在ECMAScript中，<strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起，它也常被称为<strong>类</strong>，不妥当（不具备传统面向对象语言所支持的类和接口等基本结构）。也称为<strong>对象定义</strong>，因为它们描述的是一类对象所具有的属性和方法。</p>
<p>对象时某个特定引用类型的<strong>实例</strong>。新对象是使用new操作符后跟一个<strong>构造函数</strong>来创建的。</p>
<h3 id="5-1_Object类型">5.1  Object类型</h3>
<p>创建方式：</p>
<pre><code><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();
person.name=<span class="string">"ihww"</span>;
</code></pre><p>or(<strong>对象字面量</strong>)</p>
<pre><code><span class="keyword">var</span> person={
    name:<span class="string">"ihww"</span>
}
</code></pre><h3 id="5-2_Array类型">5.2  Array类型</h3>
<p>ECMAScript数组的每一项可以保存任何类型的数据，同时数组的大小可以动态调整(如果传递的是数值，则数组的大小固定)。</p>
<p>创建方式：</p>
<pre><code><span class="keyword">var</span> names=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>)
<span class="keyword">var</span> names=<span class="built_in">Array</span>(<span class="string">"Greg"</span>)
<span class="keyword">var</span> names=[]
</code></pre><h4 id="5-2-1_检测数组">5.2.1   检测数组</h4>
<p>instanceof操作符的问题在于，它假定只有一个全局执行环境（如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数）。</p>
<pre><code><span class="built_in">Array</span>。<span class="built_in">isArray</span>(value)
</code></pre><h4 id="5-2-2_转换方法">5.2.2   转换方法</h4>
<p>toLocaleString()、toString()和valueOf()方法，默认情况一逗号分隔的字符串的形式返回数组想。而是用join()方法，则可以是用不同的分隔符来构建这个字符串。</p>
<p><code>如果数组中某一项的值是null或者undefined，则用空字符串代替</code></p>
<h4 id="5-2-3_栈方法">5.2.3   栈方法</h4>
<p>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。<br>pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。</p>
<h4 id="5-2-4_队列方法">5.2.4   队列方法</h4>
<p>shift()方法，取出第一项。<br>unshift()方法，它能在数组前端添加任意个项并返回新数组的长度。</p>
<h4 id="5-2-5_重排序方法">5.2.5   重排序方法</h4>
<p>reverse()反转数组项的顺序。<br>sort()方法可以自定义排序方法。</p>
<h4 id="5-2-6_操作方法">5.2.6   操作方法</h4>
<p>concat()、slice()、splice()</p>
<h4 id="5-2-7_位置方法">5.2.7   位置方法</h4>
<p>indexOf()和lastIndexOf()</p>
<h4 id="5-2-8_迭代方法">5.2.8    迭代方法</h4>
<p>略</p>
<h4 id="5-2-9_归并方法">5.2.9   归并方法</h4>
<p>reduce()和reduceRight()</p>
<h3 id="5-3_Date类型">5.3  Date类型</h3>
<p>日期格式化方法？<br>日期/时间组件方法？</p>
<h3 id="5-4_RegExp类型">5.4  RegExp类型</h3>
<pre><code><span class="keyword">var</span> expression= <span class="regexp">/ pattern /</span> flags;
</code></pre><p>g:表示全局模式，即模式将被应用于所有字符串<br>i:表示不区分大小写模式<br>m:表示多行模式</p>
<h4 id="5-4-1_RegExp实例属性">5.4.1   RegExp实例属性</h4>
<ul>
<li>global：布尔值，表示是否设置了g标志。</li>
<li>ignoreCase：布尔值，表示是否设置了i标志</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起</li>
<li>multiline：布尔值，表示是否设置了m标志</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数的字符串模式返回</li>
</ul>
<h4 id="5-4-2_RegExp实例方法">5.4.2   RegExp实例方法</h4>
<pre><code>var text=<span class="string">"mom and dad and baby"</span>;
var pattern=/mom( <span class="keyword">and</span> dad( <span class="keyword">and</span> baby)?)?/gi;
var <span class="operator">matches</span>=pattern.exec(text);
alert(<span class="operator">matches</span>.index);   //<span class="number">0</span>
alert(<span class="operator">matches</span>.input);   //mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby
alert(<span class="operator">matches</span>[<span class="number">0</span>]);      //mom <span class="keyword">and</span> dad <span class="keyword">and</span> baby
alert(<span class="operator">matches</span>[<span class="number">1</span>]);      // <span class="keyword">and</span> dad <span class="keyword">and</span> baby
alert(<span class="operator">matches</span>[<span class="number">2</span>]);      // <span class="keyword">and</span> baby
</code></pre><h4 id="5-4-3_RegExp构造函数属性">5.4.3   RegExp构造函数属性</h4>
<h4 id="5-4-4_模式的局限性">5.4.4   模式的局限性</h4>
<h3 id="5-5_Function类型">5.5  Function类型</h3>
<p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1,num2)</span></span>{
    <span class="keyword">return</span> num1+num2;
}
等同于
<span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span><span class="params">(num1,num2)</span></span>{
    <span class="keyword">return</span> num1+num2;
}
等同于
<span class="keyword">var</span> sum=<span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"return num1+num2"</span>)</span></span>; <span class="comment">//不推荐，会导致解析两次代码（第一次解析常规ECMAScript代码，第二次解析传入构造函数中的字符串，影响性能）</span>

函数是对象，函数名是指针
</code></pre><h4 id="5-5-1_没有重载">5.5.1   没有重载</h4>
<p>将函数名想象为指针</p>
<h4 id="5-5-2_函数声明与函数表达式">5.5.2   函数声明与函数表达式</h4>
<p>解析器率先读取函数声明，并使其在执行任何代码之前可用</p>
<h4 id="5-5-3_作为值的函数">5.5.3   作为值的函数</h4>
<h4 id="5-5-4_函数内部属性">5.5.4   函数内部属性</h4>
<p>两个特殊的对象：arguments和this。<br>argument:有一个名叫callee的属性，该属性石一个指针，指向拥有这个arguments对象的函数。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(num)</span></span>{
    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>){
        <span class="keyword">return</span> <span class="number">1</span>;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> num*factorial(num-<span class="number">1</span>)
    }
}
等同于
<span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(num)</span></span>{
    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>){
        <span class="keyword">return</span> <span class="number">1</span>;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num-<span class="number">1</span>)<span class="comment">//严格模式下，运行出错</span>
    }
}
</code></pre><p>this：this引用的是函数据以执行的环境对象</p>
<h4 id="5-5-5_函数属性和方法">5.5.5   函数属性和方法</h4>
<p>每个函数都包含两个属性：length和prototype。<br>length：表示函数希望接收的命名参数的格式（方法参数个数）<br>prototype：对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。prototype属性是不可枚举的，因此使用for-in无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：<br>apply():接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组（也可以是Array的实例）<br>call():和apply作用相同，区别仅在于接收参数的方式不同，第一个参数this没有变化，变化的是其余参数都直接传递给函数</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1,num2)</span></span>{
    <span class="keyword">return</span> num1+num2;
}
<span class="function"><span class="keyword">function</span> <span class="title">callSum1</span><span class="params">(num1,num2)</span></span>{
    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);
    <span class="comment">//return sum.apply(this,[num1,num2])</span>
}
<span class="function"><span class="keyword">function</span> <span class="title">callSum2</span><span class="params">(num1,num2)</span></span>{
    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);
}
</code></pre><p>bind():创建一个函数的实例，其this值会被绑定到传给bind()函数的值</p>
<pre><code><span class="built_in">window</span>.color=<span class="string">"red"</span>;
<span class="keyword">var</span> o={color:<span class="string">"blue"</span>}

<span class="function"><span class="keyword">function</span> <span class="title">sayColor</span><span class="params">()</span></span>{
    alert(<span class="keyword">this</span>.color);
}
<span class="keyword">var</span> objectSayColor=sayColor.bind(o);
objectSayColor();
</code></pre><h3 id="5-6_基本包装类型">5.6  基本包装类型</h3>
<p>3个特殊的引用类型：Boolean、Number和String。（基本类型值不是对象，逻辑上它们不应该有方法）</p>
<h3 id="5-7_单体内置对象">5.7  单体内置对象</h3>
<p>内置对象：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。</p>
<h4 id="5-7-1_Global对象">5.7.1   Global对象</h4>
<p>isNan()、isFinite()、parseInt()以及parseFloat()，都是Global对象的方法。</p>
<p>1.encodeURI()、encodeURIComponent()编解码url</p>
<p>2.eval()方法</p>
<pre><code><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);
</code></pre><p>3.Global对象的属性</p>
<p>?</p>
<p>4.window对象</p>
<p>Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。</p>
<h4 id="5-7-2_Math对象">5.7.2   Math对象</h4>
<p>略</p>
<h2 id="6_面向对象的程序设计">6 面向对象的程序设计</h2>
<p>对象：无序属性的集合，其属性可以包含基本值、对象或者函数（无非就是一组名值对，其中值可以是数据或函数）。每个对象都是基于一个引用类型创建的。</p>
<h3 id="6-1_理解对象">6.1  理解对象</h3>
<h4 id="6-1-1_属性类型">6.1.1   属性类型</h4>
<p>ECMAScript中有两种属性：数据属性和访问器属性。</p>
<p><strong>1.数据属性</strong></p>
<ul>
<li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li>[[Enumerable]]：表示能否通过for-in循环返回属性。</li>
<li>[[Writable]]：表示能否修改属性的值。</li>
<li>[[Value]]：包含这个属性的数据值。</li>
</ul>
<p>要修改属性默认的特性，必须使用<code>Object.defineProperty()</code>方法</p>
<p><strong>2.访问器属性</strong></p>
<ul>
<li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li>[[Enumerable]]：表示能否通过for-in循环返回属性。</li>
<li>[[Get]]：在读取属性时调用的函数。</li>
<li>[[Value]]：在写入属性时调用的函数。</li>
</ul>
<h4 id="6-1-2_定义多个属性">6.1.2   定义多个属性</h4>
<p><code>Object.defineProperties()</code>方法</p>
<h4 id="6-1-3_读取属性的特性">6.1.3   读取属性的特性</h4>
<p><code>Object.getOwnPropertyDescriptor()</code>方法</p>
<h3 id="6-2_创建对象">6.2  创建对象</h3>
<h4 id="6-2-1_工厂模式">6.2.1   工厂模式</h4>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎么知道一个对象的类型）</p>
<h4 id="6-2-2_构造函数模式">6.2.2   构造函数模式</h4>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age)</span></span>{
    <span class="keyword">this</span>.name=name;
    <span class="keyword">this</span>.age=age;
    sayName=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(<span class="keyword">this</span>.name);
    }
}
<span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"ihww"</span>,<span class="number">27</span>);

person1.constructor == Person <span class="comment">//true</span>
</code></pre><p><strong>以这种方式定义的构造函数是定义在Global对象中的</strong></p>
<p><strong>1.将构造函数当做函数</strong></p>
<pre><code><span class="comment">//当做构造函数使用</span>
<span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"ihww"</span>,<span class="number">27</span>);
person.sayName(); <span class="comment">//ihww</span>

<span class="comment">//作为普通函数调用</span>
Person(<span class="string">"abc"</span>,<span class="number">27</span>);
<span class="built_in">window</span>.sayName();<span class="comment">//abc</span>

<span class="comment">//在另一个对象的作用域中调用</span>
<span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();
Person.call(o,<span class="string">'bbb'</span>,<span class="number">27</span>)
o.sayName() <span class="comment">//bbb</span>
</code></pre><p><strong>2.构造函数的问题</strong></p>
<p>每个方法都要在每个实例上重新创建一遍。</p>
<pre><code>    <span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age)</span></span>{
        <span class="keyword">this</span>.name=name;
        <span class="keyword">this</span>.age=age;
        sayName=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>);<span class="comment">//与声明函数在逻辑上是等价的</span>
    }
</code></pre><p>从这个角度上看构造函数，每个Person实例都包含一个不同的Function实例的本质。（这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然相同）。</p>
<pre><code>alert(person1.<span class="variable">sayName =</span>= person2.sayName) //<span class="constant">false</span>   不同实例上的同名函数是不相等的
</code></pre><p>把sayName提取到全局域，导致一下问题：</p>
<ul>
<li>全局域中定义的函数实际只是被某个对象调用，名不副实</li>
<li>如果对象需要定义很多方法</li>
</ul>
<p>解决方法<strong>原型模式</strong></p>
<h4 id="6-2-3_原型模式">6.2.3   原型模式</h4>
<p>我们创建的每个函数都有一个prototype(原型)属性，该属性是一个指针，指向一个对象（该对象的用途是包含可以由特定类型的所有实例共享的属性和方法）。</p>
<p><strong>1.理解原型对象</strong></p>
<p>所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。</p>
<p>Person.prototype.constructor指向Person。而通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。</p>
<p>创建了自定义的构造函数之后，原型对象默认只会取得constructor属性，其他方法都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象（<code>_proto_</code>也可以表示为[[Prototype]]）。这个连接存在于实例与构造函数的原型对象之间，不是存在于实例与构造函数之间。</p>
<p><img src="/images/201412/prototype_1.png" alt="图6-1"></p>
<p>解释：Person.prototype指向原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性，还有其他属性。Person的实例都包含一个内部属性（<em>proto</em>），该属性仅仅指向了Person.prototype;</p>
<p>通过<code>isPrototypeOf()</code>方法来确定对象之间是否存在这种关系。</p>
<pre><code><span class="function">alert</span>(Person<span class="class">.prototype</span><span class="class">.isPrototypeOf</span>(person1))；<span class="comment">//true</span>
</code></pre><p>ECMAScript5增加了一个新方法，叫Object.getPrototypeOf(),这个方法返回<em>proto</em>的值</p>
<pre><code>alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span>
alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//Nicholas</span>
</code></pre><p><strong>每当代码读取某个对象的属性时，都会执行一次搜索，目标是具体给定名字的属性。搜索首先从对象实例本身开始，然后原型对象</strong></p>
<p><strong>实例对象能访问原型中的值，但不能修改，如果我们在实例中添加一个原型同名属性，则该属性将会屏蔽原型中的那个属性，但可以使用delete操作符完全删除实例属性</strong></p>
<p>使用<code>hasOwnProperty()</code>方法检测一个属性是否存在实例中，还是存在原型中（Object继承来的）。</p>
<p><strong>2.原型与in操作符</strong></p>
<p>两种方式使用in操作符：</p>
<ul>
<li>单独使用（通过对象能够访问给定属性时返回true）</li>
<li>for-in循环中使用</li>
</ul>
<p><code>hasPrototypeProperty()</code>检测是否是原型中属性，如果实例覆盖了原型中属性则返回false，取得对象上所有可枚举的实例属性：<code>Object.keys()</code></p>
<p><strong>3.更简单的原型语法</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>{
}
Person.prototype={
    name:<span class="string">"Nicholas"</span>,
    age:<span class="number">27</span>
}
</code></pre><p>如果在原型中声明<code>constructor</code>属性，可能导致该特性的[[Enumerable]]为true，即可枚举。</p>
<p><strong>4.原型的动态性</strong></p>
<p>由于原型中查找值的过程是一次搜索，因此原型对象所做修改立即从实例上反映出来。</p>
<p><strong>5.原生对象的原型</strong></p>
<pre><code>alert(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);<span class="comment">//function</span>
</code></pre><p>通过原生对象的原型，可以定义新方法。</p>
<p><strong>6.原型对象的问题</strong></p>
<p>引用类型值的属性被实例属性可以修改，导致其它实例值修改。</p>
<h3 id="6-2-4_组合使用构造函数模式和原型模式">6.2.4    组合使用构造函数模式和原型模式</h3>
<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。</p>
<h3 id="6-2-5_动态原型模式">6.2.5    动态原型模式</h3>
<p>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age)</span></span>{
    <span class="keyword">this</span>.name=name;
    <span class="keyword">this</span>.age=age;
    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>){
        Person.prototype.sayName=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            alert(<span class="keyword">this</span>.name);
        }
    }
}
</code></pre><p><em>不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系</em></p>
<h3 id="6-2-6_寄生构造函数模式">6.2.6    寄生构造函数模式</h3>
<p>寄生（parasitic）构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>{
    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(<span class="keyword">this</span>.name);
    };
     <span class="keyword">return</span> o;
}
<span class="keyword">var</span> friend = <span class="keyword">new</span> Person(“Nicholas”, <span class="number">29</span>, “Software Engineer”);
friend.sayName(); <span class="comment">//”Nicholas”</span>
</code></pre><p>这个模式可以在特殊的情况下用来为对象创建构造函数。如果我们想创建一个具有额外方法的特殊数组。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span><span class="params">()</span></span>{
    <span class="comment">//create the array</span>
    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();
    <span class="comment">//add the values</span>
    values.push.apply(values, <span class="built_in">arguments</span>);
    <span class="comment">//assign the method</span>
    values.toPipedString = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.join(“|”);
    };
    <span class="comment">//return it</span>
    <span class="keyword">return</span> values;
}
<span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(“red”, “blue”, “green”);
alert(colors.toPipedString()); <span class="comment">//”red|blue|green”</span>
</code></pre><h3 id="6-2-7_稳妥构造函数模式">6.2.7    稳妥构造函数模式</h3>
<p>指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（禁用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。</p>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：</p>
<ul>
<li>新创建对象的实例方法不引用this</li>
<li>不使用new操作符调用构造函数</li>
</ul>
<p>改造下前面的Person构造函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>{
    <span class="comment">//create the object to return</span>
    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
    <span class="comment">//optional: define private variables/functions here</span>
    <span class="comment">//attach methods</span>
    o.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(name);
    };
    <span class="comment">//return the object</span>
    <span class="keyword">return</span> o;
}
</code></pre><p>创建的对象，除了使用sayName()方法之外，没有其它办法访问name的值。</p>
<h2 id="6-3_继承">6.3   继承</h2>
<p>许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。（由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，实现继承主要是依靠原型链来实现的）。</p>
<h3 id="6-3-1_原型链">6.3.1    原型链</h3>
<p>基本思想是利用原型让一个引用类型继承另一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p>构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.property = <span class="literal">true</span>;
}
SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.property;
};
<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;
}
<span class="comment">//继承了SuperType</span>
SubType.prototype = <span class="keyword">new</span> SuperType();
SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;
};
<span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();
alert(instance.getSuperValue()); <span class="comment">//true</span>
</code></pre><p><img src="/images/201412/prototype_2.png" alt="6-4"></p>
<p><em>**1.别忘了默认的原型</em></p>
<p><img src="/images/201412/prototype_2.png" alt="6-5"></p>
<p><strong>2.确认原型和实例的关系</strong></p>
<p>第一种方式：</p>
<pre><code><span class="keyword">instanceof</span>
</code></pre><p>第二中方式：</p>
<pre><code><span class="built_in">Object</span>.prototype.isPrototypeOf(instance)
</code></pre><p><strong>3.谨慎地定义方法</strong></p>
<p>子类型有时候需要覆盖超类型的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p><strong>4.原型链的问题</strong></p>
<p>还是引用类型的问题，穿件子类型的实例是，不能向超类型的构造函数中传递参数。</p>
<h4 id="6-3-2_借用构造函数">6.3.2   借用构造函数</h4>
<p>为了解决引用类型值所带来的问题。在子类型构造函数的内部调用超类型构造函数，</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>{
    <span class="comment">//继承了SuperType</span>
    SuperType.call(<span class="keyword">this</span>); <span class="comment">//同样可以传递参数</span>
}
</code></pre><p>//TODO 后续小章节需要补充</p>
<h2 id="7_函数表达式">7 函数表达式</h2>
<h3 id="7-2_闭包">7.2  闭包</h3>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span><span class="params">(propertyName)</span> </span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(object1, object2)</span></span>{
        <span class="keyword">var</span> value1 = object1[propertyName];
        <span class="keyword">var</span> value2 = object2[propertyName];
        <span class="keyword">if</span> (value1 &lt; value2){
            <span class="keyword">return</span> -<span class="number">1</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2){
            <span class="keyword">return</span> <span class="number">1</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        };
}
</code></pre><p><em>闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存</em></p>
<h4 id="7-2-1_闭包与变量">7.2.1   闭包与变量</h4>
<p>闭包只能取得包含函数中任何变量的最后一个值（作用域链的配置机制引起的）。用数组分别保存。</p>
<h4 id="7-2-2_关于this对象">7.2.2   关于this对象</h4>
<p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被当做某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。</p>
<pre><code><span class="keyword">var</span> name=<span class="string">"The window"</span>;
<span class="keyword">var</span> object={
    name:<span class="string">"My Object"</span>,
    getNameFunc:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> <span class="keyword">this</span>.name;
        }
    }
};
alert(object.getNameFunc()()); <span class="comment">//The Window(非严格模式下)</span>
</code></pre><p>通常做法</p>
<pre><code><span class="keyword">var</span> name=<span class="string">"The window"</span>;
<span class="keyword">var</span> object={
    name:<span class="string">"My Object"</span>,
    getNameFunc:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">var</span> that=<span class="keyword">this</span>;
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> that.name;
        }
    }
};
alert(object.getNameFunc()()); <span class="comment">//My Object</span>
</code></pre><p><em>arguments存在同样的问题</em></p>
<h4 id="7-2-3_内存泄漏">7.2.3   内存泄漏</h4>
<p>闭包中循环引用</p>
<h3 id="7-3_模仿块级作用域">7.3  模仿块级作用域</h3>
<pre><code><span class="list">(<span class="title">function</span><span class="list">()</span>{
    //这里是快级作用域
})</span><span class="list">()</span><span class="comment">;</span>
</code></pre><h3 id="7-4_私有变量">7.4  私有变量</h3>
<p>任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数的外部访问这些变量</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span><span class="params">()</span></span>{
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable=<span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">//特权方法</span>
    <span class="keyword">this</span>.publicMethod=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        privateVariable++;
        <span class="keyword">return</span> privateFunction();
    }
}
</code></pre><h4 id="7-4-1_静态私有变量">7.4.1    静态私有变量</h4>
<pre><code>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> name = “”;
    Person = <span class="function"><span class="keyword">function</span><span class="params">(value)</span></span>{
        name = value;
    };
    Person.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> name;
    };
    Person.prototype.setName = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span></span>{
        name = value;
    };
})();
<span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(“Nicholas”);
alert(person1.getName()); <span class="comment">//”Nicholas”</span>
person1.setName(“Greg”);
alert(person1.getName()); <span class="comment">//”Greg”</span>
<span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(“Michael”);
alert(person1.getName()); <span class="comment">//”Michael”</span>
alert(person2.getName()); <span class="comment">//”Michael”</span>
</code></pre><p>变量name就变成了一个静态的，由所有实例共享的属性</p>
<h4 id="7-4-2_模块模式">7.4.2   模块模式</h4>
<p>模块模式是为了单例创建私有变量和特权方法。</p>
<pre><code><span class="keyword">var</span> singleton={
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable=<span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">return</span> {
        publicProperty:<span class="literal">true</span>,
        publicMethod:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            privateVariable++;
            <span class="keyword">return</span> privateFunction();
        }
    }
}
</code></pre><p>在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。</p>
<h4 id="7-4-3_增强的模块模式">7.4.3   增强的模块模式</h4>
<pre><code><span class="keyword">var</span> singleton={
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable=<span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="comment">//创建对象</span>
    <span class="keyword">var</span> object=<span class="keyword">new</span> CustomType();
    <span class="comment">//添加特权/共有属性和方法</span>
    object.publicProperty=<span class="literal">true</span>;
    object.publicMethod=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        privateVariable++;
        <span class="keyword">return</span> privateFunction();
    }
    <span class="comment">//返回这个对象</span>
    <span class="keyword">return</span> object;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1_JavaScript简介">1 JavaScript简介</h2>
<h3 id="1-2_JavaScript实现">1.2  JavaScript实现</h3>
<ul>
<li>核心（ECMAScript）</li>
<li>文档对象模型（DOM）</li>
<li>浏览器对象模型（BOM）</li>
</ul>
<h4 id="1-2-1_ECMAScript（提供核心语言功能）">1.2.1   ECMAScript（提供核心语言功能）</h4>
<p>规定了该门语言的下列组成部分：语法、类型、语句、关键字、保留字、操作符、对象</p>
<h4 id="1-2-2_文档对象模型（DOM）（提供访问和操作网页内容的方法和接口）">1.2.2   文档对象模型（DOM）（提供访问和操作网页内容的方法和接口）</h4>
<p>是针对XML但经过扩展用于HTML的应用程序编程接口。</p>
<p>2.DOM级别</p>
<p>DOM1级有两个模块组成：DOM核心 和 DOM HTML.（思考两个模块干嘛的）<br>DOM2级的模块：DOM试图，DOM事件（事件和事件处理的接口），DOM样式（基于CSS为元素应用样式的接口），DOM遍历和范围（遍历和操作文档树的接口）</p>
<p>3.其他DOM标准</p>
<p>SVG、MathML、SMIL</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://blog.ihww.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grunt学习笔记]]></title>
    <link href="http://blog.ihww.cn/2014/12/04/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Grunt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.ihww.cn/2014/12/04/项目管理/Grunt学习笔记/</id>
    <published>2014-12-04T01:39:20.000Z</published>
    <updated>2014-12-17T02:19:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、安装grunt">一、安装grunt</h2>
<pre><code>npm install -g grunt-<span class="keyword">cli</span>
</code></pre><p>安装grunt-cli并不等于安装了Grunt，<code>允许你在同一个系统上同时安装多个版本的 Grunt</code></p>
<h2 id="二、task配置实例">二、task配置实例</h2>
<p><strong>插件安装</strong></p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> grunt-contrib-uglify <span class="comment">--save-dev</span></span>
</code></pre><a id="more"></a>

<p><strong>配置实例</strong></p>
<p>参考：<a href="https://github.com/ihuangweiwei/aiting" target="_blank" rel="external">https://github.com/ihuangweiwei/aiting</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">module.exports = function (grunt) {</div><div class="line"></div><div class="line">    grunt.initConfig({</div><div class="line">        pkg: grunt.<span class="keyword">file</span>.readJSON(<span class="string">'package.json'</span>),</div><div class="line">        date: grunt.template.today(<span class="string">"yyyy-mm-dd"</span>),</div><div class="line">        <span class="comment">//压缩js，同样可以设置合并js</span></div><div class="line">        uglify: {</div><div class="line">            <span class="comment">//参考UglifyJS2</span></div><div class="line">            <span class="keyword">options</span>: {</div><div class="line">                compress: {</div><div class="line">                    drop_console: <span class="keyword">true</span>,</div><div class="line">                    warnings: <span class="keyword">false</span>,</div><div class="line">                    join_vars: <span class="keyword">true</span>,</div><div class="line">                    drop_debugger: <span class="keyword">true</span></div><div class="line">                },</div><div class="line">                beautify: {</div><div class="line">                    ascii_only: <span class="keyword">true</span></div><div class="line">                },</div><div class="line">                banner: <span class="string">'/*! &lt;%= pkg.name %&gt; &lt;%= date %&gt; */'</span></div><div class="line">            },</div><div class="line">            my_target: {</div><div class="line">                <span class="comment">//Compiling all files in a folder dynamically</span></div><div class="line">                files: [</div><div class="line">                    <span class="comment">//模拟使用usemin</span></div><div class="line">                    {<span class="string">"dest/js/jquery/j.js"</span>: [<span class="string">'src/js/jquery/jquery-2.1.1.js'</span>, <span class="string">'src/js/jplayer/jquery.jplayer.js'</span>]},</div><div class="line">                    {<span class="string">"dest/js/aiting.js"</span>: <span class="string">'src/js/aiting.js'</span>}</div><div class="line">                ]</div><div class="line">            }</div><div class="line">        },</div><div class="line">        <span class="comment">//压缩css</span></div><div class="line">        cssmin: {</div><div class="line">            <span class="keyword">options</span>: {</div><div class="line">                banner: <span class="string">'/* minified css file */'</span></div><div class="line">            },</div><div class="line">            my_target: {</div><div class="line">                <span class="comment">//Compiling all files in a folder dynamically</span></div><div class="line">                files: [{</div><div class="line">                    expand: <span class="keyword">true</span>,</div><div class="line">                    cwd: <span class="string">'src/css'</span>,</div><div class="line">                    src: <span class="string">'**/*.css'</span>,</div><div class="line">                    dest: <span class="string">'dest/css'</span></div><div class="line">                }]</div><div class="line">            }</div><div class="line">        },</div><div class="line">        <span class="keyword">copy</span>: {</div><div class="line">            <span class="keyword">options</span>: {</div><div class="line">                timestamp: <span class="keyword">true</span></div><div class="line">            },</div><div class="line">            my_target: {</div><div class="line">                files: [</div><div class="line">                    {</div><div class="line">                        expand: <span class="keyword">true</span>,</div><div class="line">                        cwd: <span class="string">'src/static'</span>,</div><div class="line">                        src: <span class="string">"**"</span>,</div><div class="line">                        dest: <span class="string">"dest/static"</span></div><div class="line">                    },</div><div class="line">                    {<span class="string">"dest/CNAME"</span>: <span class="string">'./CNAME'</span>},</div><div class="line">                    {<span class="string">"dest/index.html"</span>: <span class="string">'src/index.html'</span>}</div><div class="line">                ]</div><div class="line">            }</div><div class="line">        },</div><div class="line">        <span class="comment">//清除打包的文件夹</span></div><div class="line">        clean: {</div><div class="line">            folder: <span class="string">"dest"</span></div><div class="line">        },</div><div class="line">        htmlmin: {</div><div class="line">            <span class="comment">//https://github.com/kangax/html-minifier#options-quick-reference</span></div><div class="line">            <span class="keyword">options</span>: {</div><div class="line">                removeComments: <span class="keyword">true</span>,</div><div class="line">                collapseWhitespace: <span class="keyword">true</span>,</div><div class="line">                removeEmptyAttributes: <span class="keyword">true</span>,</div><div class="line">                minifyJS: <span class="keyword">true</span>,</div><div class="line">                minifyCSS: <span class="keyword">true</span></div><div class="line">            },</div><div class="line">            my_target: {</div><div class="line">                files: {</div><div class="line">                    <span class="string">'dest/index.html'</span>: <span class="string">'dest/index.html'</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">        },</div><div class="line">        <span class="comment">//一键发布github</span></div><div class="line">        <span class="string">'gh-pages'</span>: {</div><div class="line">            <span class="keyword">options</span>: {</div><div class="line">                base: <span class="string">'dest'</span>,</div><div class="line">                branch: <span class="string">'gh-pages'</span></div><div class="line">            },</div><div class="line">            src: [<span class="string">'**'</span>]</div><div class="line">        },</div><div class="line">        useminPrepare: {</div><div class="line">            html: <span class="string">'dest/index.html'</span></div><div class="line">        },</div><div class="line">        usemin: {</div><div class="line">            html: <span class="string">'dest/index.html'</span>,</div><div class="line">            <span class="keyword">options</span>: {</div><div class="line">                blockReplacements: {</div><div class="line">                    <span class="comment">//简单做个测试，可以自定义静态文件后缀，避免缓存</span></div><div class="line">                    js: function (block) {</div><div class="line">                        <span class="keyword">return</span> <span class="string">'&lt;script type="text/javascript" src="'</span> + block.dest + <span class="string">'?'</span> + grunt.template.today(<span class="string">"yyyymmdd"</span>) + <span class="string">'"&gt;&lt;/script&gt;'</span></div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        }</div><div class="line">    })</div><div class="line"></div><div class="line"></div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-clean'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-htmlmin'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-contrib-copy'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-gh-pages'</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">'grunt-usemin'</span>);</div><div class="line"></div><div class="line"></div><div class="line">    grunt.registerTask(<span class="string">"build"</span>, [<span class="string">'clean'</span>, <span class="string">'cssmin'</span>, <span class="string">'uglify'</span>, <span class="string">'copy'</span>,<span class="string">'usemin'</span>, <span class="string">'htmlmin'</span>])</div><div class="line">    grunt.registerTask(<span class="string">"deploy"</span>, [<span class="string">'build'</span>, <span class="string">'gh-pages'</span>])</div><div class="line"></div><div class="line"></div><div class="line">};</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、安装grunt">一、安装grunt</h2>
<pre><code>npm install -g grunt-<span class="keyword">cli</span>
</code></pre><p>安装grunt-cli并不等于安装了Grunt，<code>允许你在同一个系统上同时安装多个版本的 Grunt</code></p>
<h2 id="二、task配置实例">二、task配置实例</h2>
<p><strong>插件安装</strong></p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> grunt-contrib-uglify <span class="comment">--save-dev</span></span>
</code></pre>]]>
    
    </summary>
    
      <category term="前端构建" scheme="http://blog.ihww.cn/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA/"/>
    
      <category term="nodejs" scheme="http://blog.ihww.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git资料]]></title>
    <link href="http://blog.ihww.cn/2014/12/03/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Git%E8%B5%84%E6%96%99/"/>
    <id>http://blog.ihww.cn/2014/12/03/项目管理/Git资料/</id>
    <published>2014-12-03T06:22:52.000Z</published>
    <updated>2014-12-04T03:42:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、推荐学习网站">一、推荐学习网站</h2>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰 Git教程</a><br><a href="http://git.oschina.net/progit/" target="_blank" rel="external">Pro Git（中文版）</a></p>
<h2 id="二、日常git命令总结">二、日常git命令总结</h2>
<p><strong>回退版本</strong></p>
<pre><code>git log <span class="comment">--pretty=oneline</span>
git <span class="operator"><span class="keyword">reset</span> <span class="comment">--hard 3628164</span></span>
</code></pre><p><strong>撤销修改</strong></p>
<pre><code><span class="comment">git</span> <span class="comment">checkout</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">readme</span><span class="string">.</span><span class="comment">txt</span>
</code></pre><p><strong>添加远程仓库</strong></p>
<pre><code>git remote <span class="keyword">add</span> origin git_url
git <span class="keyword">push</span> -u origin master
</code></pre><p><strong>分支管理</strong></p>
<pre><code>git checkout -b dev
git merge dev
git branch <span class="operator">-d</span> dev
</code></pre><p><strong>临时Bug处理</strong></p>
<pre><code>git stash
git checkout master
git checkout <span class="attribute">-b</span> issue<span class="subst">-</span><span class="number">101</span>
<span class="attribute">...</span><span class="built_in">.</span>处理<span class="attribute">...</span><span class="built_in">.</span>
git checkout master
git merge <span class="subst">--</span>no<span class="attribute">-ff</span> <span class="attribute">-m</span> <span class="string">"merged bug fix 101"</span> issue<span class="subst">-</span><span class="number">101</span>
git branch <span class="attribute">-d</span> issue<span class="subst">-</span><span class="number">101</span>
git checkout dev
git stash <span class="built_in">list</span>
git stash pop  <span class="comment">//git stash apply stash@{0}</span>
</code></pre><p><strong>标签处理</strong></p>
<pre><code>git tag v1.<span class="number">0</span>
git tag -d v<span class="number">0</span>.<span class="number">1</span>
git push origin v1.<span class="number">0</span>
删除远程标签
先删本地
git tag -d v1.<span class="number">0</span>
git push origin <span class="symbol">:refs/tags/v1</span>.<span class="number">0</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、推荐学习网站">一、推荐学习网站</h2>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_bla]]>
    </summary>
    
      <category term="Git" scheme="http://blog.ihww.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node.js中文资源导航]]></title>
    <link href="http://blog.ihww.cn/2014/11/26/nodejs/node-js%E4%B8%AD%E6%96%87%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    <id>http://blog.ihww.cn/2014/11/26/nodejs/node-js中文资源导航/</id>
    <published>2014-11-26T02:29:39.000Z</published>
    <updated>2014-12-17T02:20:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Node-js">Node.js</h2>
<ul>
<li><a href="http://www.nodejs.org/" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://www.infoq.com/cn/articles/what-is-nodejs" target="_blank" rel="external">Infoq深入浅出Node.js系列（进阶必读）</a></li>
<li><a href="http://nodeapi.ucdok.com/#/api/" target="_blank" rel="external">Node.js中文文档</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/web/1201_wangqf_nodejs/" target="_blank" rel="external">被误解的 Node.js</a></li>
<li><a href="http://deadhorse.me/nodejs/2012/10/08/c_addon_in_nodejs_node_gyp.html" target="_blank" rel="external">Node.js C++ addon编写实战系列</a></li>
<li><a href="https://nodejsmodules.org/" target="_blank" rel="external">热门node.js模块排行榜，方便找出你想要的模块</a></li>
<li><a href="http://cnodejs.org/topic/518b679763e9f8a5424406e9" target="_blank" rel="external">nodejs多线程，真正的非阻塞</a></li>
<li><a href="http://cnodejs.org/topic/5189ff4f63e9f8a54207f60c" target="_blank" rel="external">浅析nodejs的buffer类</a></li>
<li><a href="http://cnodejs.org/topic/519ceb5263e9f8a542c19764" target="_blank" rel="external">利用libuv编写异步多线程的addon实例</a></li>
<li><a href="http://weizhifeng.net/node-js-exports-vs-module-exports.html" target="_blank" rel="external">Node.js中exports与module.exports的区别</a></li>
<li><a href="http://cnodejs.org/topic/5293550ca6957a08096508fb" target="_blank" rel="external">Node.js http 管道拒绝服务漏洞</a></li>
<li><a href="http://yaohuiji.com/2013/01/08/pro-node-article-list/" target="_blank" rel="external">Node.js高级编程</a></li>
<li><a href="https://github.com/dead-horse/node-style-guide" target="_blank" rel="external">Node.js代码风格指南</a></li>
</ul>
<h2 id="业界新闻">业界新闻</h2>
<ul>
<li><a href="http://www.csdn.net/article/2013-12-17/2817827-10-surprising-Node.js-projects" target="_blank" rel="external">NodeJS无所不能：细数10个令人惊讶的NodeJS开源项目</a></li>
<li><a href="http://www.csdn.net/article/2013-05-20/2815364-how-ebays-first-node-js-application-were-built" target="_blank" rel="external">看eBay如何评价他们的Node.js首次尝鲜</a></li>
<li><a href="http://www.csdn.net/article/2012-05-03/2805296" target="_blank" rel="external">程序员如何说服老板采用Node.js？</a></li>
<li><a href="http://www.csdn.net/article/2012-08-21/2808861" target="_blank" rel="external">百万级并发 Node.js也能行</a></li>
<li><a href="http://www.rockdai.com/?p=596" target="_blank" rel="external">高性能Node.js：来自LinkedIn Mobile的10条优化建议</a></li>
<li><a href="http://www.csdn.net/article/2013-11-25/2817617-PayPal-Kraken-Nodejs-Framework" target="_blank" rel="external">Kraken：改变PayPal开发文化的Node.js框架</a></li>
<li><a href="http://www.iteye.com/news/28358" target="_blank" rel="external">Groupon抛弃Rails，转向Node.js</a></li>
</ul>
<p><a id="more"></a></p>
<h2 id="经验分享">经验分享</h2>
<ul>
<li><a href="http://www.csdn.net/article/2012-07-30/2807863" target="_blank" rel="external">SDCC讲师专访：淘宝朴灵谈Node.js</a></li>
<li><a href="http://www.programmer.com.cn/13844/" target="_blank" rel="external">Node.js的核心与红利</a></li>
<li><a href="http://www.linuxeden.com/html/news/20130109/134241.html" target="_blank" rel="external">QCon北京2013 Node.js专题出品人朴灵专访</a></li>
<li><a href="http://ittechnical.sinaapp.com/category/node-js/" target="_blank" rel="external">一个周末掌握IT前沿技术之node.js篇</a></li>
<li><a href="http://cnodejs.org/topic/515b009a6d38277306192e4e" target="_blank" rel="external">用node+express搭建多人博客教程系列</a></li>
<li><a href="http://www.infoq.com/cn/news/2011/11/tyq-nodejs-static-file-server" target="_blank" rel="external">Node.js静态文件服务器实战</a></li>
<li><a href="http://cnodejs.org/topic/51ce18bb73c638f3706ca7bb#51ce818c73c638f3707422e6" target="_blank" rel="external">人人和微博登录模块的实现</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6801fe420101qaz2.html" target="_blank" rel="external">《京JS》会议 &amp; V8上的JS优化</a></li>
<li><a href="http://cnodejs.org/topic/505acc95fd37ea6b2f1813de" target="_blank" rel="external">沪 JS 国内讲师的 PPT 收集</a></li>
<li><a href="http://cnodejs.org/topic/525216a3f29c7bbd3c877cbf" target="_blank" rel="external">给Node.js新手的7条小建议</a></li>
</ul>
<h2 id="模块导航">模块导航</h2>
<h3 id="web服务器框架">web服务器框架</h3>
<h4 id="最流行的web框架Express">最流行的web框架Express</h4>
<ul>
<li><a href="http://expressjs.com/" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://cnodejs.org/topic/51c3ef9f73c638f37058e6bc" target="_blank" rel="external">加装涡轮，提速expressjs</a></li>
<li><a href="http://cnodejs.org/topic/4fce14e0e5e72c25180b51d1" target="_blank" rel="external">给 connect 的 static 模块加上url路径前缀</a></li>
<li><a href="http://cnodejs.org/topic/515535485dff253b374288da" target="_blank" rel="external">研究nodeclub 登陆验证逻辑的一些心得</a></li>
<li><a href="http://www.csser.com/board/4f77e6f996ca600f78000936" target="_blank" rel="external">Express.js 中文入门指引手册</a></li>
<li><a href="http://cnodejs.org/topic/51a2f562776b2e7f035f2850" target="_blank" rel="external">Connect架构初探 for 新手</a></li>
<li><a href="http://cnodejs.org/topic/51d51cd8d44cbfa3047926ba" target="_blank" rel="external">使用 Express + Socket.IO 搭建多人聊天室</a></li>
</ul>
<h4 id="国人开源web框架rrestjs">国人开源web框架rrestjs</h4>
<ul>
<li><a href="http://rrest.cnodejs.net/" target="_blank" rel="external">HomePage</a></li>
</ul>
<h4 id="实时应用web框架meteor">实时应用web框架meteor</h4>
<ul>
<li><a href="http://meteor.com/" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://cnodejs.org/topic/51b030d9555d34c678e5fb2e" target="_blank" rel="external">Meteor-DDP翻译</a></li>
<li><a href="http://cnodejs.org/topic/519b655a63e9f8a5429cb70e" target="_blank" rel="external">Meteor 非官方中文文档（不包含API部分）</a></li>
<li><a href="http://cnodejs.org/topic/50d0466b637ffa4155aed34f" target="_blank" rel="external">基于meteor开发的开源项目列表</a></li>
</ul>
<h4 id="基于Express的实时MVC框架Sails">基于Express的实时MVC框架Sails</h4>
<ul>
<li><a href="https://github.com/balderdashy/sails" target="_blank" rel="external">HomePage</a></li>
</ul>
<h4 id="Koa，下一代_Node-js_web_框架">Koa，下一代 Node.js web 框架</h4>
<ul>
<li><a href="http://koajs.com" target="_blank" rel="external">HomePage</a></li>
<li><a href="https://github.com/turingou/koa-guide" target="_blank" rel="external">koa-guide</a></li>
<li><a href="https://github.com/dead-horse/koa-middlewares" target="_blank" rel="external">koa-middlewares</a> koa常用中间件集合</li>
</ul>
<h3 id="Mysql_老牌关系型数据库">Mysql 老牌关系型数据库</h3>
<ul>
<li><a href="https://github.com/felixge/node-mysql" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://cnodejs.org/topic/51a8c64d555d34c67835037d" target="_blank" rel="external">mysql处理BIGINT里面的一个坑</a></li>
<li><a href="http://cnodejs.org/topic/51676ac26d38277306fe7c85" target="_blank" rel="external">使用node-mysql中的连接池</a></li>
<li><a href="http://cnodejs.org/topic/516b77e86d382773064266df" target="_blank" rel="external">mysql自动断开解决办法</a></li>
</ul>
<h3 id="Mongodb">Mongodb</h3>
<ul>
<li><a href="https://github.com/mongodb/node-mongodb-native" target="_blank" rel="external">node-mongodb-native</a></li>
<li><a href="https://github.com/LearnBoost/mongoose" target="_blank" rel="external">mongoose</a></li>
<li><a href="http://cnodejs.org/topic/51508570604b3d512113f1b3" target="_blank" rel="external">如何使用mongoose对一个100万+的mongodb的表进行遍历操作</a></li>
<li><a href="http://cnodejs.org/topic/5190d61263e9f8a542acd83b" target="_blank" rel="external">[技术讨论]mongodb驱动的正确使用方法</a></li>
</ul>
<h3 id="异步流程处理">异步流程处理</h3>
<h4 id="async">async</h4>
<ul>
<li><a href="https://github.com/caolan/async" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://freewind.me/blog/20120518/932.html" target="_blank" rel="external">Async中文详解</a></li>
</ul>
<h4 id="eventproxy">eventproxy</h4>
<ul>
<li><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">HomePage</a></li>
</ul>
<h4 id="Q_Promise_异步模式">Q Promise 异步模式</h4>
<ul>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://www.ituring.com.cn/article/54547" target="_blank" rel="external">在Node.js 中用 Q 实现Promise – Callbacks之外的另一种选择</a></li>
</ul>
<h4 id="co">co</h4>
<ul>
<li><a href="https://github.com/visionmedia/co" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://www.html-js.com/article/column/77" target="_blank" rel="external">深入理解 Yield</a></li>
<li><a href="https://github.com/visionmedia/co/wiki" target="_blank" rel="external">co wiki</a></li>
</ul>
<h4 id="异步解决方案示例"><a href="https://github.com/dead-horse/callback_hell" target="_blank" rel="external">异步解决方案示例</a></h4>
<h3 id="Redis_内存键值数据库">Redis 内存键值数据库</h3>
<ul>
<li><a href="https://github.com/mranney/node_redis" target="_blank" rel="external">node_redis</a></li>
</ul>
<h3 id="Pomelo_网易出品的网页游戏框架">Pomelo 网易出品的网页游戏框架</h3>
<ul>
<li><a href="https://github.com/NetEase/pomelo" target="_blank" rel="external">pomelo</a></li>
<li><a href="http://www.infoq.com/cn/articles/game-server-development-1" target="_blank" rel="external">Infoq深入浅出node.js游戏服务器开发</a></li>
<li><a href="https://github.com/NetEase/pomelo/wiki/Home-in-Chinese" target="_blank" rel="external">官网wiki</a></li>
<li><a href="http://nodejs.netease.com/" target="_blank" rel="external">响应非常迅速的官方论坛</a></li>
</ul>
<h3 id="字符格式">字符格式</h3>
<ul>
<li><a href="http://cnodejs.org/topic/516a96d16d38277306349507" target="_blank" rel="external">開源的簡繁轉換庫OpenCC支持Node.js了</a></li>
<li><a href="http://cnodejs.org/topic/51923a2f63e9f8a542c71123" target="_blank" rel="external">iconv-lite扩展：增加big5/shift-jis支持</a></li>
</ul>
<h3 id="网页模板引擎">网页模板引擎</h3>
<ul>
<li><a href="http://cnodejs.org/topic/50e70edfa7e6c6171a1d70fa" target="_blank" rel="external">WEB模板jade、ejs、handlebars 万行代码解释效率比较，jade完败</a></li>
<li><a href="http://cnodejs.org/topic/4f16442ccae1f4aa27001109" target="_blank" rel="external">Javascript模板引擎性能对比及几点优化</a></li>
<li><a href="http://cnodejs.org/topic/51c2c2e373c638f3703f4929" target="_blank" rel="external">让 ejs 更加快 | Let ejs faster with options._with = false</a></li>
<li><a href="http://www.csser.com/board/4fddc4f0b28ed7d857001674" target="_blank" rel="external">EJS快速入门教程</a></li>
</ul>
<h3 id="图片处理">图片处理</h3>
<ul>
<li><a href="http://cnodejs.org/topic/512b9fecdf9e9fcc580eb248" target="_blank" rel="external">Nodejs跨平台轻量级图片编解码库【增加Jpeg质量调整】</a></li>
<li><a href="http://cnodejs.org/topic/50f90d8edf9e9fcc58a5ee0b" target="_blank" rel="external">node-ccap模块生成captcha验证码</a></li>
<li><a href="http://cnodejs.org/topic/4f939c84407edba2143c12f7" target="_blank" rel="external">使用nodejs将html5 canvas base64编码图片保存为文件</a></li>
<li><a href="https://github.com/dead-horse/web-camera" target="_blank" rel="external">web-camera，node + phantomjs 网页截图</a></li>
</ul>
<h3 id="运维">运维</h3>
<ul>
<li><a href="http://deadhorse.me/nodejs/2013/04/13/exception_and_domain.html" target="_blank" rel="external">Node.js 异步异常的处理与domain模块解析</a></li>
<li><a href="http://cnodejs.org/topic/50463565329c5139760c34a1" target="_blank" rel="external">关于XSS（跨站脚本攻击）和CSRF（跨站请求伪造）</a></li>
<li><a href="http://cnodejs.org/topic/51cc49e973c638f37042f7b4" target="_blank" rel="external">forever 替代工具 pm2 的介绍</a></li>
<li><a href="http://cnodejs.org/topic/51c562d673c638f3707bb8cc" target="_blank" rel="external">upstart封装mongodb应用为系统服务</a></li>
<li><a href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/" target="_blank" rel="external">告别node-forever,拥抱PM2</a></li>
<li><a href="http://cnodejs.org/topic/5059ce39fd37ea6b2f07e1a3" target="_blank" rel="external">阿里云主机Nginx下配置NodeJS、Express和Forever</a></li>
</ul>
<h2 id="性能测试">性能测试</h2>
<ul>
<li><a href="http://www.tbdata.org/archives/1285" target="_blank" rel="external">阿里出品的node.js调研与服务性能测试</a></li>
<li><a href="http://snoopyxdy.blog.163.com/blog/static/6011744020117315192204/" target="_blank" rel="external">多核单服务器各种配置和业务压力下的node.js性能测试</a></li>
<li><a href="http://snoopyxdy.blog.163.com/blog/static/60117440201183101319257/" target="_blank" rel="external">巅峰对决：node.js和php性能测试</a></li>
</ul>
<h2 id="活跃开发者（排名不分先后）">活跃开发者（排名不分先后）</h2>
<ul>
<li><a href="https://github.com/JacksonTian" target="_blank" rel="external">朴灵</a></li>
<li><a href="http://deadhorse.me/" target="_blank" rel="external">dead_horse/死马</a></li>
<li><a href="http://snoopyxdy.blog.163.com/" target="_blank" rel="external">snoopyxdy</a></li>
<li><a href="http://fengmk2.github.io/" target="_blank" rel="external">Python发烧友</a></li>
<li><a href="http://ucdok.com/" target="_blank" rel="external">老雷</a></li>
<li><a href="http://cnodejs.org/user/shiedman" target="_blank" rel="external">shiedman</a></li>
<li><a href="http://tiye.me" target="_blank" rel="external">jiyinyiyong</a></li>
</ul>
<h2 id="开源案例_收集Cnode的开源项目">开源案例 收集Cnode的开源项目</h2>
<h3 id="社交类">社交类</h3>
<ul>
<li><a href="https://github.com/cnodejs/nodeclub/" target="_blank" rel="external">Cnodejs 最活跃的Node.js社区</a></li>
<li><a href="http://cnodejs.org/topic/50f8bbfedf9e9fcc58a015ab" target="_blank" rel="external">晓知 个人博客</a></li>
<li><a href="https://github.com/willerce/canku" target="_blank" rel="external">使用Nodejs编写多人订餐系统</a></li>
<li><a href="http://cnodejs.org/topic/517b4be16d38277306984a81" target="_blank" rel="external">NodeJS写的WebQQ</a></li>
<li><a href="http://cnodejs.org/topic/51be6c2960af11cd33604776" target="_blank" rel="external">Yblog 博客程序</a></li>
<li><a href="http://cnodejs.org/topic/5023eeb9f767cc9a51032f68" target="_blank" rel="external">noderce博客程序</a></li>
</ul>
<h3 id="工具类">工具类</h3>
<ul>
<li><a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="external">cnpmjs.org 企业级 npm 解决方案</a></li>
<li><a href="https://github.com/node-webot/wechat" target="_blank" rel="external">wechat微信中间件</a></li>
<li><a href="http://cnodejs.org/topic/51cb771973c638f3701acecd" target="_blank" rel="external">深度遍历目录/列出目录下所有文件</a></li>
<li><a href="https://github.com/sumory/lincell" target="_blank" rel="external">lincell发布0.1.1版本，一行命令创建IDE</a></li>
<li><a href="http://cnodejs.org/topic/5058962f8ea56b5e7806b2a3" target="_blank" rel="external">HTML标签XSS过滤模块</a></li>
<li><a href="https://github.com/leizongmin/node-segment" target="_blank" rel="external">基于Node.js的中文分词模块</a></li>
<li><a href="http://cnodejs.org/topic/51c044ee57628b975f088c7a" target="_blank" rel="external">纯真IP库lib-qqwry</a></li>
<li><a href="http://cnodejs.org/topic/51ae41d7555d34c678ab4cce" target="_blank" rel="external">豆瓣SDK</a></li>
<li><a href="http://cnodejs.org/topic/51e7b69af4963ade0e2332a5" target="_blank" rel="external">数字与字符串转换模块baseN，支持2~62间任意进制转换</a></li>
</ul>
<h2 id="商业应用">商业应用</h2>
<ul>
<li><a href="http://mofang.taobao.com/" target="_blank" rel="external">淘宝数据魔方</a></li>
<li><a href="http://shu.taobao.com/" target="_blank" rel="external">淘宝指数</a></li>
<li><a href="http://me.taobao.com" target="_blank" rel="external">淘宝时光机</a></li>
<li><a href="http://www.diandian.com/" target="_blank" rel="external">点点网</a></li>
<li><a href="http://huaban.com/" target="_blank" rel="external">花瓣网</a></li>
<li><a href="http://xueqiu.com/" target="_blank" rel="external">雪球网</a></li>
<li>小米手机抢购</li>
<li>网易pomelo消息推送系统</li>
<li>PayPal</li>
<li>Groupon</li>
<li>百度推送平台</li>
<li>新浪微博DB proxy</li>
<li>腾讯朋友网推送</li>
</ul>
<p>转至：<a href="https://github.com/youyudehexie/node123" target="_blank" rel="external">https://github.com/youyudehexie/node123</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Node-js">Node.js</h2>
<ul>
<li><a href="http://www.nodejs.org/" target="_blank" rel="external">HomePage</a></li>
<li><a href="http://www.infoq.com/cn/articles/what-is-nodejs" target="_blank" rel="external">Infoq深入浅出Node.js系列（进阶必读）</a></li>
<li><a href="http://nodeapi.ucdok.com/#/api/" target="_blank" rel="external">Node.js中文文档</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/web/1201_wangqf_nodejs/" target="_blank" rel="external">被误解的 Node.js</a></li>
<li><a href="http://deadhorse.me/nodejs/2012/10/08/c_addon_in_nodejs_node_gyp.html" target="_blank" rel="external">Node.js C++ addon编写实战系列</a></li>
<li><a href="https://nodejsmodules.org/" target="_blank" rel="external">热门node.js模块排行榜，方便找出你想要的模块</a></li>
<li><a href="http://cnodejs.org/topic/518b679763e9f8a5424406e9" target="_blank" rel="external">nodejs多线程，真正的非阻塞</a></li>
<li><a href="http://cnodejs.org/topic/5189ff4f63e9f8a54207f60c" target="_blank" rel="external">浅析nodejs的buffer类</a></li>
<li><a href="http://cnodejs.org/topic/519ceb5263e9f8a542c19764" target="_blank" rel="external">利用libuv编写异步多线程的addon实例</a></li>
<li><a href="http://weizhifeng.net/node-js-exports-vs-module-exports.html" target="_blank" rel="external">Node.js中exports与module.exports的区别</a></li>
<li><a href="http://cnodejs.org/topic/5293550ca6957a08096508fb" target="_blank" rel="external">Node.js http 管道拒绝服务漏洞</a></li>
<li><a href="http://yaohuiji.com/2013/01/08/pro-node-article-list/" target="_blank" rel="external">Node.js高级编程</a></li>
<li><a href="https://github.com/dead-horse/node-style-guide" target="_blank" rel="external">Node.js代码风格指南</a></li>
</ul>
<h2 id="业界新闻">业界新闻</h2>
<ul>
<li><a href="http://www.csdn.net/article/2013-12-17/2817827-10-surprising-Node.js-projects" target="_blank" rel="external">NodeJS无所不能：细数10个令人惊讶的NodeJS开源项目</a></li>
<li><a href="http://www.csdn.net/article/2013-05-20/2815364-how-ebays-first-node-js-application-were-built" target="_blank" rel="external">看eBay如何评价他们的Node.js首次尝鲜</a></li>
<li><a href="http://www.csdn.net/article/2012-05-03/2805296" target="_blank" rel="external">程序员如何说服老板采用Node.js？</a></li>
<li><a href="http://www.csdn.net/article/2012-08-21/2808861" target="_blank" rel="external">百万级并发 Node.js也能行</a></li>
<li><a href="http://www.rockdai.com/?p=596" target="_blank" rel="external">高性能Node.js：来自LinkedIn Mobile的10条优化建议</a></li>
<li><a href="http://www.csdn.net/article/2013-11-25/2817617-PayPal-Kraken-Nodejs-Framework" target="_blank" rel="external">Kraken：改变PayPal开发文化的Node.js框架</a></li>
<li><a href="http://www.iteye.com/news/28358" target="_blank" rel="external">Groupon抛弃Rails，转向Node.js</a></li>
</ul>
<p>]]>
    
    </summary>
    
      <category term="nodejs" scheme="http://blog.ihww.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <link href="http://blog.ihww.cn/2014/11/25/blog/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.ihww.cn/2014/11/25/blog/hexo博客搭建/</id>
    <published>2014-11-25T05:18:02.000Z</published>
    <updated>2014-12-04T03:41:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、hexo环境安装">一、hexo环境安装</h2>
<p>安装nodejs环境</p>
<p>执行<code>npm install hexo -g</code></p>
<p><a id="more"></a></p>
<h2 id="二、hexo博客创建">二、hexo博客创建</h2>
<pre><code>hexo <span class="keyword">init</span> ihww-blog
</code></pre><h2 id="三、主题安装">三、主题安装</h2>
<p><strong><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题下载</a></strong></p>
<p>在theme目录下</p>
<pre><code>git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/hexojs/hexo-theme-light.git
</code></pre><p>修改<code>_config.yml</code> 下的theme参数修改为 <code>hexo-theme-light</code></p>
<pre><code><span class="attribute">theme</span>: <span class="string">hexo-theme-light</span>
</code></pre><h2 id="四、发布到github">四、发布到github</h2>
<p>修改<code>_config.yml</code></p>
<pre><code>deploy:
  <span class="class"><span class="keyword">type</span>: <span class="title">github</span></span>
  repo: git@github.com:ihuangweiwei/ihww-blog.git
</code></pre><p>执行</p>
<pre><code><span class="title">hexo</span> deploy
</code></pre><h2 id="五、自定义域名">五、自定义域名</h2>
<ol>
<li>dns服务CNAME到github提供的域名</li>
<li>在source目录下创建CANME文件，填写自己的域名<code>blog.ihww.cn</code></li>
</ol>
<h2 id="六、推荐站点">六、推荐站点</h2>
<p><a href="http://ijiaober.github.io/categories/hexo/" target="_blank" rel="external">http://ijiaober.github.io/categories/hexo/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、hexo环境安装">一、hexo环境安装</h2>
<p>安装nodejs环境</p>
<p>执行<code>npm install hexo -g</code></p>
<p>]]>
    
    </summary>
    
      <category term="nodejs" scheme="http://blog.ihww.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redmine2.5.2安装简要笔记]]></title>
    <link href="http://blog.ihww.cn/2014/08/08/ruby/Redmine2.5.2%E5%AE%89%E8%A3%85%E7%AE%80%E8%A6%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.ihww.cn/2014/08/08/ruby/Redmine2.5.2安装简要笔记/</id>
    <published>2014-08-08T06:22:52.000Z</published>
    <updated>2014-12-16T07:23:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、安装ruby">一、安装ruby</h2>
<p>安装脚本</p>
<pre><code><span class="comment">#/bin/bash</span>
curl -L get.rvm.io | bash <span class="operator">-s</span> stable
<span class="built_in">source</span> ~/.bashrc
<span class="built_in">source</span> ~/.bash_profile
<span class="built_in">source</span> /usr/local/rvm/scripts/rvm
sed -i <span class="string">'s!ftp.ruby-lang.org/pub/ruby!ruby.taobao.org/mirrors/ruby!'</span> <span class="variable">$rvm_path</span>/config/db
rvm install <span class="number">1.9</span>.<span class="number">3</span>
rvm use <span class="number">1.9</span>.<span class="number">3</span> --default
<span class="keyword">exit</span> <span class="number">0</span>
</code></pre><h2 id="二、安装redmine">二、安装redmine</h2>
<h3 id="2-1_下载">2.1  下载</h3>
<p>略</p>
<h3 id="2-2_安装">2.2 安装</h3>
<pre><code><span class="title">tar</span> xvf redmine...tar.gz
</code></pre><p>配置下config目录下的configuration.yml，database.yml，至于mysql的配置省略</p>
<pre><code>bundle <span class="operator"><span class="keyword">install</span></span>
</code></pre><p>完毕后不要忘了执行</p>
<pre><code>rake <span class="keyword">d</span><span class="variable">b:migrate</span> RAILS_ENV=<span class="string">"production"</span>
rake generate_session_store
</code></pre><h3 id="2-3_主题">2.3  主题</h3>
<pre><code>git clone 到 `<span class="regexp">/usr/</span>local<span class="regexp">/www/</span>redmine-<span class="number">2.5</span>.<span class="number">2</span><span class="regexp">/public/</span>themes`，到后台配置里面选定
</code></pre><h3 id="2-4_插件">2.4  插件</h3>
<pre><code>git clone 到 `<span class="regexp">/usr/</span>local<span class="regexp">/www/</span>redmine-<span class="number">2.5</span>.<span class="number">2</span><span class="regexp">/plugins`</span>
</code></pre><h3 id="2-5_完成执行">2.5  完成执行</h3>
<pre><code><span class="attribute">rake redmine:plugins:migrate RAILS_ENV</span>=<span class="string">production</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、安装ruby">一、安装ruby</h2>
<p>安装脚本</p>
<pre><code><span class="comment">#/bin/bash</span>
curl -L get.rvm.io | bash <span class="operat]]>
    </summary>
    
      <category term="ruby" scheme="http://blog.ihww.cn/tags/ruby/"/>
    
  </entry>
  
</feed>
